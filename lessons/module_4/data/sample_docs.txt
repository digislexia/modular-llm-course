# Примеры документов для практики RAG

Этот файл содержит набор коротких документов для тестирования RAG-системы.
Каждый документ отделён разделителем "---".

---
ДОКУМЕНТ 1: Python - списки

Списки в Python — это упорядоченные изменяемые коллекции объектов. Они создаются с помощью квадратных скобок: my_list = [1, 2, 3]. Списки могут содержать элементы разных типов. Основные операции: append() для добавления элемента, remove() для удаления, len() для получения длины. Списки поддерживают индексацию и срезы: list[0] — первый элемент, list[-1] — последний, list[1:3] — срез.

---
ДОКУМЕНТ 2: Python - словари

Словари (dict) в Python — это неупорядоченные коллекции пар ключ-значение. Создаются с помощью фигурных скобок: my_dict = {"name": "Alice", "age": 30}. Ключи должны быть неизменяемыми (строки, числа, кортежи). Доступ к значению: dict["key"]. Методы: keys() — все ключи, values() — все значения, items() — пары ключ-значение. Метод get() возвращает значение или None, если ключа нет.

---
ДОКУМЕНТ 3: Python - функции

Функции в Python определяются с помощью ключевого слова def. Синтаксис: def имя_функции(параметры):. Функции могут возвращать значения с помощью return. Аргументы могут иметь значения по умолчанию: def greet(name="World"). Python поддерживает *args для произвольного числа позиционных аргументов и **kwargs для именованных. Lambda-функции — анонимные функции: lambda x: x * 2.

---
ДОКУМЕНТ 4: Python - классы

Классы в Python создаются с помощью ключевого слова class. Метод __init__ — конструктор для инициализации объекта. self — ссылка на текущий экземпляр. Наследование: class Child(Parent). Инкапсуляция: атрибуты с _ считаются защищёнными, с __ — приватными. Методы класса создаются декоратором @classmethod, статические — @staticmethod. Специальные методы: __str__, __repr__, __len__.

---
ДОКУМЕНТ 5: Python - исключения

Обработка исключений в Python осуществляется конструкцией try-except. Синтаксис: try: код except Exception as e: обработка. Можно указывать конкретные типы исключений: except ValueError, except KeyError. Блок finally выполняется всегда. Блок else выполняется, если исключения не было. Для генерации исключений используется raise: raise ValueError("Сообщение"). Создание своих исключений: class MyError(Exception): pass.

---
ДОКУМЕНТ 6: Python - файлы

Работа с файлами в Python осуществляется через функцию open(). Режимы: 'r' — чтение, 'w' — запись, 'a' — добавление, 'b' — бинарный режим. Рекомендуется использовать контекстный менеджер: with open('file.txt', 'r') as f:. Методы чтения: read() — весь файл, readline() — одна строка, readlines() — список строк. Для записи: write() и writelines(). Кодировка указывается параметром encoding='utf-8'.

---
ДОКУМЕНТ 7: Python - модули

Модули в Python — это файлы с расширением .py, содержащие код. Импорт: import module_name или from module import function. Пакеты — директории с файлом __init__.py. Стандартная библиотека включает модули: os (работа с ОС), sys (системные параметры), json (JSON), datetime (дата/время), re (регулярные выражения). Установка сторонних модулей: pip install package_name.

---
ДОКУМЕНТ 8: Python - декораторы

Декораторы в Python — это функции, которые модифицируют поведение других функций. Синтаксис: @decorator перед определением функции. Декоратор принимает функцию и возвращает обёртку. Пример: @staticmethod, @classmethod, @property. Можно создавать свои декораторы. Декораторы с аргументами требуют дополнительной вложенности. functools.wraps сохраняет метаданные оригинальной функции.

---
ДОКУМЕНТ 9: Python - генераторы

Генераторы в Python — функции, использующие yield вместо return. Они создают итераторы, вычисляя значения по требованию (lazy evaluation). Генераторные выражения: (x*2 for x in range(10)). Экономят память при работе с большими данными. Методы: next() для получения следующего значения, send() для отправки значения в генератор. Генераторы нельзя перезапустить — нужно создавать заново.

---
ДОКУМЕНТ 10: Python - асинхронность

Асинхронное программирование в Python использует модуль asyncio. Ключевые слова: async def для асинхронных функций, await для ожидания результата. asyncio.run() запускает главную корутину. asyncio.gather() для параллельного выполнения. Асинхронность полезна для I/O-bound операций: сетевые запросы, работа с базами данных. Для CPU-bound задач лучше использовать multiprocessing.

---
ДОКУМЕНТ 11: Machine Learning - основы

Машинное обучение (ML) — подраздел искусственного интеллекта, где системы учатся на данных. Три типа: supervised learning (обучение с учителем), unsupervised learning (без учителя), reinforcement learning (обучение с подкреплением). Supervised learning использует размеченные данные для задач классификации и регрессии. Unsupervised находит паттерны в неразмеченных данных: кластеризация, снижение размерности.

---
ДОКУМЕНТ 12: Machine Learning - нейронные сети

Нейронные сети — модели, вдохновлённые биологическим мозгом. Состоят из слоёв нейронов (узлов). Входной слой принимает данные, скрытые слои обрабатывают, выходной даёт результат. Каждая связь имеет вес. Активационные функции: ReLU, sigmoid, tanh. Обучение происходит через backpropagation — обратное распространение ошибки. Глубокое обучение (deep learning) использует много скрытых слоёв.

---
ДОКУМЕНТ 13: Machine Learning - трансформеры

Трансформеры — архитектура нейронных сетей для обработки последовательностей. Представлены в статье "Attention is All You Need" (2017). Ключевой механизм — self-attention, позволяющий учитывать контекст всей последовательности. Энкодер обрабатывает входные данные, декодер генерирует выходные. BERT использует только энкодер, GPT — только декодер. Трансформеры — основа современных LLM.

---
ДОКУМЕНТ 14: LLM - большие языковые модели

Большие языковые модели (LLM) — нейронные сети с миллиардами параметров, обученные на огромных текстовых корпусах. Примеры: GPT-4, Claude, LLaMA. Обучаются предсказывать следующий токен. Демонстрируют emergent abilities — способности, не заложенные явно. In-context learning позволяет решать задачи по примерам в промпте. Fine-tuning адаптирует модель под конкретные задачи.

---
ДОКУМЕНТ 15: LLM - промпт-инжиниринг

Промпт-инжиниринг — искусство формулирования запросов к LLM для получения качественных ответов. Техники: zero-shot (без примеров), few-shot (с примерами), chain-of-thought (пошаговое рассуждение). Важные элементы: чёткие инструкции, контекст, формат вывода. System prompt задаёт роль и поведение модели. Temperature влияет на креативность: 0 — детерминированный, 1 — максимальное разнообразие.

---
ДОКУМЕНТ 16: RAG - Retrieval-Augmented Generation

RAG (Retrieval-Augmented Generation) — технология, дополняющая LLM внешними знаниями. Состоит из двух компонентов: retriever (находит релевантные документы) и generator (генерирует ответ). Retriever использует семантический поиск по векторной базе. Generator — LLM, получающая контекст из найденных документов. RAG уменьшает галлюцинации и позволяет работать с актуальными данными.

---
ДОКУМЕНТ 17: Эмбеддинги

Эмбеддинги (embeddings) — векторные представления текста в многомерном пространстве. Похожие по смыслу тексты имеют близкие векторы. Создаются специальными моделями: text-embedding-ada-002, sentence-transformers. Размерность обычно 384-1536. Позволяют выполнять семантический поиск вместо точного совпадения. Косинусное сходство измеряет близость векторов. Эмбеддинги — ключевой компонент RAG.

---
ДОКУМЕНТ 18: Векторные базы данных

Векторные базы данных оптимизированы для хранения и поиска эмбеддингов. Примеры: Pinecone, Weaviate, Qdrant, Chroma, FAISS. Используют алгоритмы ANN (Approximate Nearest Neighbors) для быстрого поиска. HNSW — популярный алгоритм индексации. Поддерживают метаданные для фильтрации. Chroma — open-source решение с простым API. FAISS от Meta — высокопроизводительная библиотека.

---
ДОКУМЕНТ 19: Chunking в RAG

Chunking — разбиение документов на фрагменты для индексации в RAG. Стратегии: фиксированный размер (по токенам), по предложениям, по параграфам. Overlap — перекрытие между чанками для сохранения контекста. Размер чанка влияет на качество: слишком маленькие теряют контекст, большие снижают точность поиска. Оптимальный размер: 200-500 токенов с overlap 50-100.

---
ДОКУМЕНТ 20: Оценка качества RAG

Метрики качества RAG: Retrieval Relevance (релевантность найденных документов), Answer Faithfulness (соответствие ответа источникам), Answer Relevance (релевантность ответа вопросу). RAGAS — фреймворк для автоматической оценки. LLM-as-judge использует модель для оценки качества. A/B тестирование сравнивает разные конфигурации. Важно тестировать на реальных пользовательских запросах.

